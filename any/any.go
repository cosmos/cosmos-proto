// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Code generated by protoc-gen-go. DO NOT EDIT.
// source: google/protobuf/any.proto

// Package anypb contains generated types for google/protobuf/any.proto.
//
// The Any message is a dynamic representation of any other message value.
// It is functionally a tuple of the full name of the remote message type and
// the serialized bytes of the remote message value.
//
//
// Constructing an Any
//
// An Any message containing another message value is constructed using New:
//
//	any, err := anypb.New(m)
//	if err != nil {
//		... // handle error
//	}
//	... // make use of any
//
//
// Unmarshaling an Any
//
// With a populated Any message, the underlying message can be serialized into
// a remote concrete message value in a few ways.
//
// If the exact concrete type is known, then a new (or pre-existing) instance
// of that message can be passed to the UnmarshalTo method:
//
//	m := new(foopb.MyMessage)
//	if err := any.UnmarshalTo(m); err != nil {
//		... // handle error
//	}
//	... // make use of m
//
// If the exact concrete type is not known, then the UnmarshalNew method can be
// used to unmarshal the contents into a new instance of the remote message type:
//
//	m, err := any.UnmarshalNew()
//	if err != nil {
//		... // handle error
//	}
//	... // make use of m
//
// UnmarshalNew uses the global type registry to resolve the message type and
// construct a new instance of that message to unmarshal into. In order for a
// message type to appear in the global registry, the Go type representing that
// protobuf message type must be linked into the Go binary. For messages
// generated by protoc-gen-go, this is achieved through an import of the
// generated Go package representing a .proto file.
//
// A common pattern with UnmarshalNew is to use a type switch with the resulting
// proto.Message value:
//
//	switch m := m.(type) {
//	case *foopb.MyMessage:
//		... // make use of m as a *foopb.MyMessage
//	case *barpb.OtherMessage:
//		... // make use of m as a *barpb.OtherMessage
//	case *bazpb.SomeMessage:
//		... // make use of m as a *bazpb.SomeMessage
//	}
//
// This pattern ensures that the generated packages containing the message types
// listed in the case clauses are linked into the Go binary and therefore also
// registered in the global registry.
//
//
// Type checking an Any
//
// In order to type check whether an Any message represents some other message,
// then use the MessageIs method:
//
//	if any.MessageIs((*foopb.MyMessage)(nil)) {
//		... // make use of any, knowing that it contains a foopb.MyMessage
//	}
//
// The MessageIs method can also be used with an allocated instance of the target
// message type if the intention is to unmarshal into it if the type matches:
//
//	m := new(foopb.MyMessage)
//	if any.MessageIs(m) {
//		if err := any.UnmarshalTo(m); err != nil {
//			... // handle error
//		}
//		... // make use of m
//	}
//
package any

import (
	"google.golang.org/protobuf/proto"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	"google.golang.org/protobuf/types/known/anypb"
)

// New marshals src into a new Any instance.
func New(src proto.Message) (*anypb.Any, error) {
	dst := new(anypb.Any)
	if err := MarshalFrom(dst, src, proto.MarshalOptions{}); err != nil {
		return nil, err
	}
	return dst, nil
}

// MarshalFrom marshals src into dst as the underlying message
// using the provided marshal options.
//
// If no options are specified, call dst.MarshalFrom instead.
func MarshalFrom(dst *anypb.Any, src proto.Message, opts proto.MarshalOptions) error {
	if src == nil {
		return protoimpl.X.NewError("invalid nil source message")
	}
	b, err := opts.Marshal(src)
	if err != nil {
		return err
	}
	dst.TypeUrl = string(src.ProtoReflect().Descriptor().FullName())
	dst.Value = b
	return nil
}
